<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>07-箭头函数以及声明特点</title>
  </head>
  <body>
    <script>
      /**
       * 1、箭头函数是用来简化函数定义语法的
       * 2、箭头函数的简写 
       *  1) 当形参有且只有一个的时候可以省略小括号
       *  2) 当函数体只有一句语句时可以省略大括号
       *  3) 当函数体只有一句语句且有返回值时大括号省略时return必须省略
       * 3、箭头函数不绑定this 箭头函数没有自己的this关键字 如果在箭头函数中使用this this关键字将指向箭头函数定义位置中的this，即内外 this 一致
       * 4、不能作为构造函数实例化对象
       * 5、不能使用 arguments 变量
       */
      // 1、简化函数声明一个箭头函数
      {
        let fn = (a, b) => {
          console.log(a, b);
        };
        fn(1, 2); // 1 2
      }

      // 2、箭头函数的简写
      // 1) 省略小括号，当形参有且只有一个的时候
      let add = n => {
        return n + n;
      };
      console.log(add(111)); // 222
      // 23) 省略花括号，当代码体只有一条语句的时候，此时 return 必须省略
      // 而且语句的执行结果就是函数的返回值
      let pow = n => n * n;
      console.log(pow(2)); // 4

      // 3、this 是静态的，this关键字将指向箭头函数定义位置中的this
      function getName() {
        console.log(this.name);
      }
      let getName2 = () => {
        console.log(this.name);
      };
      // 设置 window 对象的 name 属性
      window.name = "shadow";
      const person = {
        name: "oracle",
      };
      // 直接调用 this 指向 window
      getName(); // shadow
      getName2(); // shadow
      // call 方法调用，按理说 this 指向的是 call 方法传递的对象，但是箭头函数调用方是 window，所以还是指向 window
      getName.call(person); // oracle
      getName2.call(person); // shadow this 没有发生改变，当前指向 window

      // 2.不能作为构造函数实例化对象
      let Person = (name, age) => {
        this.name = name;
        this.age = age;
      };
      // let me = new Person('shadow', 22) // Person is not a constructor

      // 3.不能使用 arguments 变量
      let fn = () => {
        console.log(arguments)
      }
      // fn(1, 2, 3) // arguments is not defined
    </script>
  </body>
</html>
